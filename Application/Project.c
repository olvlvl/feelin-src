/*

$VER: 12.00 (2006/06/25)

	FSignalHandler is now deprecated, the structure is no longer provided to
	the  'AddSignalHandler'  method.  Instead, a taglist must be provided to
	create an  abstract  'handler'.  This  behaviour  has  been  chosen  for
	security purpose because a provided structure could easily be corrupted,
	corrupting the whole handlers list. Because it's not the 'real'  pointer
	that is returned, the handler cannot be disposed by mistake.

	Methods  deprecated:  'Resolve',  'ResolveInt',  'ObtainAssociated'  and
	'ReleaseAssociated'.

	Added 'AddStyleSheet' and 'RemStyleSheet' methods.

$VER: 11.00 (2005/12/08)

	Modify resources creation order.
	
	Added 'associated data' support through the new
	FM_Application_ObtainAssociated and FM_Application_ReleaseAssociated
	methods.

	FEvents are now generated by WinServer, events handling is  now  limited
	to invoking the FM_Widget_HandleEvent method on the 'target' object.

	[GROG] io_Command = TR_ADDREQUEST forgotten in Application_AddSignal.

*/

#include "Project.h"

///globals
struct ClassUserData                *CUD;

#if defined(__amigaos4__)
struct Library                      *RexxSysBase;
struct RexxSysIFace                 *IRexxSys;
#elif defined(__MORPHOS__)
struct Library                      *RexxSysBase;
#else
struct RxsLib                       *RexxSysBase;
#endif

struct Library                      *DiskfontBase;

#ifdef __amigaos4__
struct DiskfontIFace                *IDiskfont;
#endif

struct Library                      *CxBase;

#ifdef __amigaos4__
struct CommoditiesIFace             *ICommodities;
#endif

struct Library                      *IFFParseBase;

#ifdef __amigaos4__
struct IFFParseIFace                *IIFFParse;
#endif
//+

///METHODS
F_METHOD_PROTO(void,Application_New);
F_METHOD_PROTO(void,Application_Dispose);
F_METHOD_PROTO(void,Application_Set);
F_METHOD_PROTO(void,Application_Get);
F_METHOD_PROTO(void,Application_AddMember);
F_METHOD_PROTO(void,Application_RemMember);
F_METHOD_PROTO(void,Application_Connect);
F_METHOD_PROTO(void,Application_Disconnect);

F_METHOD_PROTO(void,Application_Run);
F_METHOD_PROTO(void,Application_Shutdown);
F_METHOD_PROTO(void,Application_Awake);
F_METHOD_PROTO(void,Application_Sleep);
F_METHOD_PROTO(void,Application_PushMethod);
F_METHOD_PROTO(void,Application_Setup);
F_METHOD_PROTO(void,Application_Cleanup);
F_METHOD_PROTO(void,Application_Load);
F_METHOD_PROTO(void,Application_Save);
F_METHOD_PROTO(void,Application_OpenFont);
F_METHOD_PROTO(void,Application_CreateSignalHandle);
F_METHOD_PROTO(void,Application_DeleteSignalHandle);
F_METHOD_PROTO(void,Application_Update);
F_METHOD_PROTO(void,Application_AddStyleSheet);
F_METHOD_PROTO(void,Application_RemStyleSheet);
F_METHOD_PROTO(void,Application_Post);
F_METHOD_PROTO(void,Application_PostClean);
//+

///update_dbg

struct FS_DOSNotify_Notify                      { STRPTR FileName; };

F_HOOKM(void,update_dbg,FS_DOSNotify_Notify)
{
   STRPTR buf = IFEELIN F_New(1024);

   CUD->db_Push   = FALSE;
   CUD->db_Events = FALSE;

   if (buf)
   {
	  BPTR file = IDOS_ Open(Msg->FileName,MODE_OLDFILE);

	  if (file)
	  {
		 if (IDOS_ FGets(file,buf,1024))
		 {
			struct RDArgs *rda = (struct RDArgs *) IDOS_ AllocDosObject(DOS_RDARGS,NULL);

			if (rda)
			{
			   rda->RDA_Source.CS_Buffer = buf;
			   rda->RDA_Source.CS_Length = IFEELIN F_StrLen(buf);

			   if (IDOS_ ReadArgs(TEMPLATE, (LONG *) &CUD->db_Array, rda))
			   {
				  IDOS_ FreeArgs(rda);
			   }
			   IDOS_ FreeDosObject(DOS_RDARGS,rda);
			}
		 }
		 IDOS_ Close(file);
	  }
	  IFEELIN F_Dispose(buf);
   }
}
//+

///Class_New
F_METHOD(uint32,Class_New)
{
	CUD = F_LOD(Class,Obj);

	CUD->db_Notify = DOSNotifyObject,

	   "FA_DOSNotify_Name", "ENV:Feelin/DBG_APPLICATION",

	   End;

	IFEELIN F_Do(CUD->db_Notify,FM_Notify,"FA_DOSNotify_Update",FV_Notify_Always, FV_Notify_Self,FM_CallHookEntry,2,update_dbg,FV_Notify_Value);
	IFEELIN F_Set(CUD->db_Notify,(uint32) "FA_DOSNotify_Update", (uint32) "ENV:Feelin/DBG_APPLICATION");
	
/*** open libraries ****************************************************************************/

	/* rexxsyslib */
 
	#if defined(__MORPHOS__) || defined(__amigaos4__)
	RexxSysBase = IEXEC OpenLibrary("rexxsyslib.library",36);
	#else
	RexxSysBase = (struct RxsLib *) IEXEC OpenLibrary("rexxsyslib.library",36);
	#endif
	
	#ifdef __amigaos4__
	
	if (RexxSysBase)
	{
		if (!(IRexxSys = (struct RexxSysIFace *) IEXEC GetInterface((struct Library *) RexxSysBase,"main",1,NULL)))
		{
			IEXEC CloseLibrary((struct Library *) RexxSysBase);
			 
			RexxSysBase = NULL;
		}
	}
	
	#endif
	
	/* commodities */

	CxBase = IEXEC OpenLibrary("commodities.library",39);
	
	#ifdef __amigaos4__

	if (CxBase)
	{
		if (!(ICommodities = (struct CommoditiesIFace *) IEXEC GetInterface((struct Library *) CxBase,"main",1,NULL)))
		{
			IEXEC CloseLibrary((struct Library *) CxBase);
			
			CxBase = NULL;
		}
	}
	
	#endif

	/* iffparse */
 
	IFFParseBase = IEXEC OpenLibrary("iffparse.library",36);
	
	#ifdef __amigaos4__
	
	if (IFFParseBase)
	{
		if (!(IIFFParse = (struct IFFParseIFace *) IEXEC GetInterface((struct Library *) IFFParseBase,"main",1,NULL)))
		{
			IEXEC CloseLibrary((struct Library *) IFFParseBase);
			
			IFFParseBase = NULL;
		}
	}
	
	#endif
	
	/* diskfont */
 
	DiskfontBase = IEXEC OpenLibrary("diskfont.library",39);

	#ifdef __amigaos4__
	
	if (DiskfontBase)
	{
		if (!(IDiskfont = (struct DiskfontIFace *) IEXEC GetInterface((struct Library *) DiskfontBase,"main",1,NULL)))
		{
			IEXEC CloseLibrary((struct Library *) DiskfontBase);
			
			DiskfontBase = NULL;
		}
	}
	
	#endif
		
	/* FIXME: REXX should be optional */
  
	if (RexxSysBase && CxBase && IFFParseBase && DiskfontBase)
	{
		return F_SUPERDO();
	}

	return 0;
}
//+
///Class_Dispose
F_METHOD(uint32,Class_Dispose)
{
	CUD = F_LOD(Class,Obj);
 
	IFEELIN F_DisposeObj(CUD->db_Notify); CUD->db_Notify = NULL;
	
	if (DiskfontBase)
	{
		#ifdef __amigaos4__
		 
		IEXEC DropInterface((struct Interface *) IDiskfont); IDiskfont = NULL;
		
		#endif
		
		IEXEC CloseLibrary(DiskfontBase); DiskfontBase = NULL;
	}

	if (IFFParseBase)
	{
		#ifdef __amigaos4__

		IEXEC DropInterface((struct Interface *) IIFFParse); IIFFParse = NULL;

		#endif
		
		IEXEC CloseLibrary(IFFParseBase); IFFParseBase = NULL;
	}
		
	if (RexxSysBase)
	{
		#ifdef __amigaos4__

		IEXEC DropInterface((struct Interface *) IRexxSys); IRexxSys = NULL;
		
		#endif
		 
		IEXEC CloseLibrary((struct Library *) RexxSysBase); RexxSysBase = NULL;
	}
	
	if (CxBase)
	{
		#ifdef __amigaos4__
		
		IEXEC DropInterface((struct Interface *) ICommodities); ICommodities = NULL;
		
		#endif
	
		IEXEC CloseLibrary(CxBase); CxBase = NULL;
	}
	
	return F_SUPERDO();
}
//+

F_QUERY()
{
   switch (Which)
   {
///Meta
	  case FV_Query_MetaClassTags:
	  {
		 STATIC F_METHODS_ARRAY =
		 {
			F_METHODS_OVERRIDE_STATIC(Class_New,      FM_New),
			F_METHODS_OVERRIDE_STATIC(Class_Dispose,  FM_Dispose),

			F_ARRAY_END
		 };

		 STATIC F_TAGS_ARRAY =
		 {
			F_TAGS_ADD_SUPER(Class),
			F_TAGS_ADD(LocalSize, sizeof (struct ClassUserData)),
			F_TAGS_ADD_METHODS,

			F_ARRAY_END
		 };

		 return F_TAGS_PTR;
	  }
//+
///Class
		case FV_Query_ClassTags:
		{
			STATIC F_ATTRIBUTES_ARRAY =
			{
				F_ATTRIBUTES_ADD_STATIC("Title",          FV_TYPE_STRING,  FA_Application_Title),
				F_ATTRIBUTES_ADD_STATIC("Version",        FV_TYPE_STRING,  FA_Application_Version),
				F_ATTRIBUTES_ADD_STATIC("Copyright",      FV_TYPE_STRING,  FA_Application_Copyright),
				F_ATTRIBUTES_ADD_STATIC("Author",         FV_TYPE_STRING,  FA_Application_Author),
				F_ATTRIBUTES_ADD_STATIC("Description",    FV_TYPE_STRING,  FA_Application_Description),
				F_ATTRIBUTES_ADD_STATIC("Base",           FV_TYPE_STRING,  FA_Application_Base),
				F_ATTRIBUTES_ADD_STATIC("Unique",         FV_TYPE_BOOLEAN, FA_Application_Unique),
				F_ATTRIBUTES_ADD_STATIC("Signal",         FV_TYPE_FLAGS,   FA_Application_Signal),
				F_ATTRIBUTES_ADD_STATIC("UserSignals",    FV_TYPE_FLAGS,   FA_Application_UserSignals),
				F_ATTRIBUTES_ADD_STATIC("BrokerPort",     FV_TYPE_POINTER, FA_Application_BrokerPort),
				F_ATTRIBUTES_ADD_STATIC("BrokerHook",     FV_TYPE_POINTER, FA_Application_BrokerHook),
				F_ATTRIBUTES_ADD_STATIC("BrokerPri",      FV_TYPE_INTEGER, FA_Application_BrokerPri),
				F_ATTRIBUTES_ADD_STATIC("Broker",         FV_TYPE_POINTER, FA_Application_Broker),
				F_ATTRIBUTES_ADD_STATIC("Display",        FV_TYPE_OBJECT,  FA_Application_Display),
				F_ATTRIBUTES_ADD_STATIC("Preference",     FV_TYPE_OBJECT,  FA_Application_Preference),
				F_ATTRIBUTES_ADD_STATIC("Sleep",          FV_TYPE_BOOLEAN, FA_Application_Sleep),

				F_ARRAY_END
			};

			STATIC F_METHODS_ARRAY =
			{
				F_METHODS_OVERRIDE_STATIC(Application_New, 			 FM_New),
				F_METHODS_OVERRIDE_STATIC(Application_Dispose, 		 FM_Dispose),
				F_METHODS_OVERRIDE_STATIC(Application_Get, 			 FM_Get),
				F_METHODS_OVERRIDE_STATIC(Application_Set, 			 FM_Set),
				F_METHODS_OVERRIDE_STATIC(Application_AddMember, 	 FM_AddMember),
				F_METHODS_OVERRIDE_STATIC(Application_RemMember, 	 FM_RemMember),
				F_METHODS_OVERRIDE_STATIC(Application_Connect, 		 FM_Connect),
				F_METHODS_OVERRIDE_STATIC(Application_Disconnect, 	 FM_Disconnect),

				F_METHODS_ADD_STATIC(Application_Run,          		  "Run",              FM_Application_Run),
				F_METHODS_ADD_STATIC(Application_Shutdown,     		  "Shutdown",         FM_Application_Shutdown),
				F_METHODS_ADD_STATIC(Application_Sleep,        		  "Sleep",            FM_Application_Sleep),
				F_METHODS_ADD_STATIC(Application_Awake,        		  "Awake",            FM_Application_Awake),
				F_METHODS_ADD_STATIC(Application_Post,                "Post", 			  FM_Application_Post),
				F_METHODS_ADD_STATIC(Application_PostClean,           "PostClean", 		  FM_Application_PostClean),
				F_METHODS_ADD_STATIC(Application_PushMethod,   		  "PushMethod",       FM_Application_PushMethod),
				F_METHODS_ADD_STATIC(Application_CreateSignalHandle,  "CreateSignalHandle", FM_Application_CreateSignalHandler),
				F_METHODS_ADD_STATIC(Application_DeleteSignalHandle,  "DeleteSignalHandle", FM_Application_DeleteSignalHandler),
				F_METHODS_ADD_STATIC(Application_AddStyleSheet,       "AddStyleSheet",    FM_Application_AddStyleSheet),
				F_METHODS_ADD_STATIC(Application_RemStyleSheet,       "RemStyleSheet",    FM_Application_RemStyleSheet),
				F_METHODS_ADD_STATIC(Application_Setup,        		  "Setup",            FM_Application_Setup),
				F_METHODS_ADD_STATIC(Application_Cleanup,      		  "Cleanup",          FM_Application_Cleanup),
				F_METHODS_ADD_STATIC(Application_Load,         		  "Load",             FM_Application_Load),
				F_METHODS_ADD_STATIC(Application_Save,         		  "Save",             FM_Application_Save),
				F_METHODS_ADD_STATIC(Application_OpenFont,            "OpenFont",         FM_Application_OpenFont),
				F_METHODS_ADD_STATIC(Application_Update,              "Update",           FM_Application_Update),
				
				F_ARRAY_END
			};

			STATIC F_TAGS_ARRAY =
			{
				F_TAGS_ADD_SUPER(Family),
				F_TAGS_ADD_LOD,
				F_TAGS_ADD_METHODS,
				F_TAGS_ADD_ATTRIBUTES,

				F_ARRAY_END
			};

			return F_TAGS_PTR;
		}
//+
	}
	return NULL;
}

/*

$VER: Application 10.10 (2005/04/29)

	The semaphore is now unlocked when  waiting  signals.  Waiting  signals
	under  the  protected state of the semaphore locking, was locking other
	tasks pushing methods.

	The flag FF_EVENT_BUTTON_DOUBLE is  now  set  with  mouse  button  down
	(FF_EVENT_BUTTON_DOWN), instead of mouse button up.

	Replaced event class codes FV_EVENT_BUTTON_UP and  FF_EVENT_BUTTON_DOWN
	by FV_EVENT_BUTTON_WHEEL. The flag FF_EVENT_BUTTON_DOWN indicates wheel
	direction.

$VER: Application 10.00 (2005/02/04)

	Added    preference     resolving     mapping.     With     the     new
	FA_Application_ResolveMapping  attribute,  the developer can now easily
	override any user preference item. This was  a  problem  with  previous
	version  because  some  preference  items  cannot  be  overridden  e.g.
	"FP_Decorator_AScheme". It's so easy now, it's nearly ridiculous :-)

	Own event system, IDCMP is deprecated. Icon drop support.

$VER: Application 09.00 (2004/12/18)

	The class is now a subclass of FC_Family.

	The variable DBG_APPLICATION can be used to toggle verbose output.  The
	variable is read with ReadArgs(). Thus, many switches can be defined in
	a single file.

	The method FM_Application_Run has been completely  rewritten.  It  runs
	locked  and  only  unlocks when exiting the loop (e.g. when invoking an
	object). The implementation of the  FM_Application_Run  method  is  far
	more  secure than before. More over, the application runs faster and is
	more responsive.

	New preference update mechanism.

	The      flag      FF_SignalHandler_Active      is      set      during
	FM_Application_CreateSignalHandler, to indicate that the handler is linked
	and active, and cleared  during  FM_Application_DeleteSignalHandler.  This
	flag  is  not  used by FC_Application, but can be used by developers to
	check if a handler is active before removing  it,  although  trying  to
	remove  a  not  active  (linked) handler causes no harms, but a message
	logging.

	** PRIVATE **

	The method FM_Application_Shutdown does no longer send a message (which
	could fails to allocate). Instead, the flag FF_Application_Run is used.
	When  the   flag   is   cleared   the   application   exit   from   the
	FM_Application_Run.  The  FF_Application_Update  flag  is  also  use to
	indicate that the application should update  because  preferences  have
	changed.

*/
